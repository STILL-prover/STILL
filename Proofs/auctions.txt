:init "auctions"
-- :theoremE "receiveBids" Forall "curBid" (Var "nat") (TyNu "Y" (Forall "newBid" (Var "nat") (TyVar "Y")))
:theorem "receiveBids" forall curBid : nat . nu Y . forall newBid : nat . Y
:apply _ForallR
:apply (_NuR "AUC" ["bid"] ["curBid"])
:apply _ForallR
:apply (_Weaken "curBid")
:apply (_TyVar "AUC" ["newBid"])
:done
-- z(curBid).(corec AUC(bid).z(newBid).AUC(newBid)) (curBid)

:{
:theorem "english"
    forall ItemType:stype.
    forall bid:Type 1.
    forall zeroB:bid.
    forall validNewB:(Pi b1:bid. Pi b2:bid. Type 1).
    forall currency:(Pi b:bid.Type 1).
    ItemType -o
    (forall b:bid. $currency b -o 1) -o
    forall firstB:bid.
    forall firstValid:validNewB zeroB firstB.
    $currency firstB -o
    (ItemType + $currency firstB -o 1) -o
    nu Y. (forall newB:bid.
        forall nextValid:validNewB firstB newB.
        $currency newB -o
        (ItemType + $currency newB -o 1) -o Y) & 1
:}
:apply _Intros
:{
:apply _NuR "AUC"
    ["item", "ownerC", "curB", "winnerChan", "oldB", "lastB", "curValid"]
    ["a", "c", "d", "e", "zeroB", "firstB", "firstValid"]
:}
:apply _WithR
:apply _ForallLA
:apply _FTac (_FExact (Var "firstB"))
:apply _ImpliesLA
:apply _UnitLA
:apply _ImpliesLA
:apply _UnitLA
:apply _UnitR
:apply _PlusR1
:apply _IdA
:apply _IdA
:apply _ImpliesLA
:apply _UnitLA
:apply _Intros
:defer
:apply _PlusR2
:apply _IdA
:apply _Weaken "zeroB"
:apply _Weaken "firstValid"
:apply _TyVar "AUC" ["a", "c", "i", "j", "firstB", "newB", "nextValid"]
:done
-- z(ItemType).z(bid).z(zeroB).z(validNewB).z(currency).z(a).z(c).z(firstB).z(firstValid).z(d).z(e).
--  (corec AUC(item, ownerChan, curBid, winnerChan, oldBid, lastBid, curValid).z.case((ν h)winnerChan[h].(h.inr;[curBid <-> h]) | (z(newB).z(nextValid).z(i).z(j).AUC(item, ownerChan, i, j, lastBid, newB, nextValid)), ownerChan[lastBid].(ν f)ownerChan[f].([curBid <-> f]) | ((ν g)winnerChan[g].(g.inl;[item <-> g]) | (0)) )) (a, c, d, e, zeroB, firstB, firstValid)

-- Demonstrate a different proof and extraction of the english auction.
-- It receives the new bid before returning the old one. Original english returns then receives the new one.
:{
:theorem "english2"
    forall ItemType:stype.
    forall bid:Type 1.
    forall zeroB:bid.
    forall validNewB:(Pi b1:bid. Pi b2:bid. Type 1).
    forall currency:(Pi b:bid.Type 1).
    ItemType -o
    (forall b:bid. $currency b -o 1) -o
    forall firstB:bid.
    forall firstValid:validNewB zeroB firstB.
    $currency firstB -o
    (ItemType + $currency firstB -o 1) -o
    nu Y. (forall newB:bid.
        forall nextValid:validNewB firstB newB.
        $currency newB -o
        (ItemType + $currency newB -o 1) -o Y) & 1
:}
:apply _Intros
:{
:apply _NuR "AUC"
    ["item", "ownerC", "curB", "winnerC", "oldB", "lastB", "curValid"]
    ["a", "c", "d", "e", "zeroB", "firstB", "firstValid"]
:}
:apply _WithR
:apply _ForallLA
:apply _FTac (_FExact (Var "firstB"))
:apply _ImpliesLA
:apply _UnitLA
:apply _ImpliesLA
:apply _UnitLA
:apply _UnitR
:apply _PlusR1
:apply _IdA
:apply _IdA
:apply _Intros
:apply _ImpliesLA
:apply _UnitLA
:defer
:apply _PlusR2
:apply _IdA
:apply _Weaken "zeroB"
:apply _Weaken "firstValid"
:apply _TyVar "AUC" ["a", "c", "h", "i", "firstB", "newB", "nextValid"]
:done
-- z(ItemType).z(bid).z(zeroB).z(validNewB).z(currency).z(a).z(c).z(firstB).z(firstValid).z(d).z(e).(corec AUC(item, ownerC, curB, winnerC, oldB, lastB, curValid).z.case(inl: z(newB).z(nextValid).z(h).z(i).((ν j) winnerC[j].(j.inr;[curB <-> j] | AUC(item, ownerC, h, i, lastB, newB, nextValid))), inr: ownerC[lastB].((ν f) ownerC[f].([curB <-> f] | (ν g) winnerC[g].(g.inl;[item <-> g] | 0))) )) (a, c, d, e, zeroB, firstB, firstValid)
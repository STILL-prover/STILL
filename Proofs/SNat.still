-- Lfix X . F X = ALL X . F X -o X
-- Nat = Lfix X . 1 + X = ALL X . (1 + X -o X) -o X
-- In general the least fix point requires a replicating term. Toninho and Yoshida: ALL X . !(1 + X -o X) -o X.
-- But linear natural numbers seem to work.
-- Recursive Types for Free by Wadler 1990 https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
module SNat begin

theorem z: "forall X : stype. (1 + X -o X) -o X"
-- :theorem "ztest" Forall2 "X" (Implication (Implication (Plus Unit (TyVar "X")) (TyVar "X")) (TyVar "X"))
apply Intros
apply ImpliesLA
apply IdA
apply PlusR1
apply UnitR
done
-- z(X).z(a).(ν b)a[b].(b.inl;0) | ([a <-> z])

theorem succ: "(forall X : stype. (1 + X -o X) -o X) -o (forall Y:stype. (1 + Y -o Y) -o Y)"
apply ImpliesR
apply Forall2R
apply Forall2L a "Y"
apply IdA
done
-- z(a).z(Y).a[Y].[a <-> z]

theorem one: "forall X:stype. (1 + X -o X) -o X"
apply Cut "(forall X : stype. (1 + X -o X) -o X) -o (forall Y:stype. (1 + Y -o Y) -o Y)"
apply Cut "forall X : stype. (1 + X -o X) -o X"
apply ImpliesLA
apply Forall2R
apply Forall2L a "X"
apply IdA
apply IdA
-- z
apply Intros
apply ImpliesLA
apply IdA
apply PlusR1
apply UnitR
-- succ
apply ImpliesR
apply Forall2R
apply Forall2L f "Y"
apply IdA
done
-- one: ; ; ;  |- z:∀X. (1 ⊕ X ⊸ X) ⊸ X
-- (ν a)(a(b).a(Y).b[Y].[b <-> a]) | ((ν c)(c(X).c(d).(ν e)d[e].(e.inl;0) | ([d <-> c])) | ((ν f)a[f].([c <-> f]) | (z(X).a[X].[a <-> z])))

-- Use previous theorems.
theorem two: "forall X:stype. (1 + X -o X) -o X"
apply CutTheorem one
apply CutTheorem succ
apply ImpliesLA
apply Forall2R
apply Forall2L b "X"
apply IdA
apply IdA
done